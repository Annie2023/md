调用约定stdcall、cdecl、fastcall

数组和结构体

都是连续分配内存空间

结构体sizeof

字符集乱码问题：ASCII+gbk；unicode

main函数

```c
位置：exelmain->tmain->main......
特征：三个参数(argc,argv,envp)、结合上下文eg：push（三个push+一个call不一定是，pe文件格式）
调用固定函数（sleep，kernel.....）GetVersion

exit
```

crtexe.c

if分支函数识别

```
cmp 
   jxx   if+xxxh
end
```

ifelse双分支函数识别

if、elseif、esle多分支和switchcase

**区分：switch必须break；否则case语句会顺序执行不会跳出，多执行很多东西**；画图没有交叉每个case之间的jump是平行的关系

```
cmp 
if语句：   jxx   if+xxxh   跳else
               {
   
                   jxx   跳到else之后
                }
else：语句  {
  
}
end
```

**switch分支数>=5时，会形成一张索引数组存放case，索引从0开始（ecx，edx）**

[(i-1)*4+数组首地址]

case不规则，按最大的存，没用的就没用

for循环编译器规则：

```
i=0->jump 到比较条件（第一次不做i++，该语句只执行了一次）->i++->比较条件->执行里面语句或者跳转
```

# 消息

事件->系统（消息进入系统队列，通过hwnd找到应用程序）->应用程序

1. 类型
2. 坐标
3. 时间
4. 标语
5. 附加

windows消息机制：

```c
typedef struct tagMSG{
    HWND hwnd;
    UINT
    WARAPM
    LPARAM;
    DWORD time;
    POINT pt;
}WARAM
```

常见消息：

```

```

postMessage（异步，无阻塞）/sendMessage（同步）

GetMessage（取消息）            /PeekMessage（确认是否有消息）

```c
getMoudleHandle


WINmain{
   里面有一些回调函数之类的
   Registerclass
}


消息回调函数，窗口处理自定义
#include<Windows.h>
  
LRESULT CALLBACK WindowPROC{
    HWND hwnd;
    UINT
    WARAPM
    LPARAM;
}  //系统通过DisPatchMessage调用，通过hwnd->一堆数据结构里面的main->找到自己的回调函数
    
窗口类（比较固定）创建并且注册进内核

HWND hwnd = CreateWindow（）；
返给hwnd
资源指向内存，内存的东西再显存

ShowWindow()
UpdateWindow();

while(取消息){
    TranslateMessage（消息）
    DispatchMessage（消息）
}
    
 寻找回调函数：
     1.找winmain
     2.Registerclass
```

```c
消息处理（）{
    switch(){
        case 1:
            ;
        case 2:
            ;
        case WM_COMMAND:
            switch(){
                    case ...
                    case WParam
            }
    }
}
```

WM_COMMAND

1.  用户点击按钮   
2. 选择菜单
3. 选择控件
4. 发送给父函数的处理函数

类->对话框->刷新->消息循环

创建对话框（模块/非模块对话框）：模块限制，当前必须先处理不能处理其他

```
DialogBoxParam

资源模板（
```

# 断点

内存断点

查看几个窗口

三个窗口    软件断点

resourcehacker找主窗口

回到用户代码段（在用户处下内存断点）

# 激活

```
import threading
import time
def test():
    for i in range(2):
        time.sleep(1)#设置一个等待时间
       # print('这是第%s线程'%threading.current_thread().name)
        print('我是一个线程，线程id为%d，我创建了\n学号：2022132006\n'%threading.currentThread().ident)

if __name__ == '__main__':
    my_list = []
    for i in range(5):
        a = threading.Thread(target=test)
        my_list.append(a)
    for j in my_list:
        j.start()
    for m in my_list:
        m.join()

    print('线程id，线程终止退出')
```

结构化异常处理

加载基址随机化（一般改成00不让它随机化）

PE脱壳（解密+windowsPE加载器：所有函数名替换成函数地址（调相应的函数））

1）esp定律找OEP（对整个环境的保存执行完壳后要恢复代码）方法：在保存现场后下一个断点，等要恢复的时候也就是壳要执行完的时候

2）、两次内存断点

3）单步执行（跳跃很大）

4）



脱壳障碍：有可能内存不可读，可能会修改pe里面的数据（需要修正pe文件的大小），反调试手段
