## 名词翻译

DFD图 ：数据`流`图  Data Flow Diagram

E-R图：实体-联系图  Entity-Relationship

IPO图：输入、处理、输出图	processes

HIPO图：==层次图==＋输入/处理/输出图	Hierarchy

PAD图：问题分析图 Problem Analysis Diagram

PDL：过程设计语言 Process Design Language

UML：统一建模语言 ==Unified Modeling== Language

==CASE：结构化分析与设计工具==

OOP：面向对象==编程== 	Object Oriented Programming

OOD：面向对象设计

==SWEBOK：软件工程知识体系==

软件工程Software Engineering

软件需求Software Requirements

软件设计Software Design

软件过程Software Process

开源项目Open source project

人工智能 artificial intelligence

软件部署software deployment

软件建构Software Construction

系统软件System software

应用软件Application software

嵌入式软件 Embedded software

分布式计算 ==Distributed== computing

软件过程Software Process

软件测试Software Test

软件质量Software Quality

软件危机Software Crisis

## 概述（第一章）

==软件 = 程序+数据+文档==

### 软件危机与软件工程的提出

20世纪60年代末，由于软件规模扩大、软件复杂性提高导致软件开发开发周期长、成本高、质量差和维护困难，爆发了软件危机，为了克服软件危机，1968年北大西洋公约组织（NATO）提出了软件工程的概念，试图将工程化的方法应用于软件开发。

许多软件项目不能满足客户的要求

许多软件项目超出预算和时间安排

**软件危机定义：**在计算机软件**开发和维护**过程中所遇到的一系列严重问题

### 软件工程的目的

解决软件危机

### 面向对象方法的四个要点

面向对象方法学(面向对象范型)

1. 把==对象==作为融合了数据及在数据上操作的软件构件。即用==对象分解==取代了传统方法的==功能分解==。
2. 把所有对象都划分成类。
3. 按照==父类与子类==的关系,把若干个相关类组织成一个层次结构的系统。
4. 对象彼此间仅能通过发送消息互相联系。

### 生命周期模型定义与阶段划分（大阶段与小阶段），各个阶段的目的、任务*

* **生命周期模型定义**：软件生命周期由软件定义、软件开发和运行维护（软件维护）三个时期组成，每个时期又进一步划分成若干个阶段

![image-20241224142151735](https://starofeden-blog.oss-cn-chengdu.aliyuncs.com/img/202412241421837.png)

### **各个阶段的目的、任务（简答题）**

（P12）

## 第2章 可行性研究

### 可行性研究的任务，三个基本的可行性

目的：**不是解决问题**，而是确定问题**是否能够解决**、是否**值得去解决**。

* **三个基本可行性**

**==技术==可行性**：使用现有的技术能实现这个系统吗?

**==经济==可行性**：这个系统的经济效益能超过它的开发成本吗?

**==操作==可行性**：系统的操作方式在这个用户组织内行得通吗?

其它：法律、社会文化可行性等

### 系统流程图

概括地描绘物理系统的传统工具，表达数据在系统各部件之间的流动情况，而不是对数据进行加工处理的过程（偏底层）

### 数据流图

DFD

描绘数据在软件中的流动和被处理的逻辑过程

![image-20241224193734562](https://starofeden-blog.oss-cn-chengdu.aliyuncs.com/img/202412241937689.png)

### 数据字典的作用与符号表示

**数据字典**是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合。

* **作用**：

在软件分析和设计的过程中给人提供关于数据的描述信息

* **符号表示**：

![image-20241224194609628](https://starofeden-blog.oss-cn-chengdu.aliyuncs.com/img/202412241946708.png)

（）表示可选

## 第3章

### 需求分析的任务

* 需求分析阶段的基本任务：确定系统功能
不是确定系统怎样完成它的工作，而是确定系统必须**完成哪些工作**也就是对目标系统提出完整、准确、清晰、具体的要求。

1. 确定对系统的==综合要求==(功能需求、性能需求、可靠性和可用性需求、出错处理需求、接口需求、约束、逆向需求和将来可能提出的要求)
2. 分析系统的==数据==要求
3. 导出系统==逻辑模型==
4. 修正系统==开发==计划

### **系统的综合需求（简答题）**（8分）

（p56）

功能需求

性能需求

可靠性和可用性需求

出错处理需求

接口需求

约束

逆向需求

将来可能提出的要求

### 与用户沟通获取需求的方法

1. 访谈(正式和非正式)
2. 面向数据流自顶向下求精
3. 简易的应用规格说明技术(面向团队的需求收集方法)
4. 快速建立软件原型(快速原型两个特性:快速和容易修改)(快速构建和修改原型方法和工具:第四代技术，可重用软件构件，形式化规格说明和原型环境)       

### 需求分析阶段建立的三种模型（对应三种工具）及其作用

* ==数据==模型——==实体-联系图==（E-R）
  描绘数据对象及数据对象之间的关系，是用于建立数据模型的图形
* ==功能==模型——==数据流图==
  描绘当数据在软件系统中移动时被变换的逻辑过程，指明系统具有的变换数据的功能，因此，数据流图是建立功能模型的基础
* ==行为==模型——==状态转换图==
  状态转换图指明了作为外部事件结果的系统行为。为此，状态转换图描绘了系统的各种行为模式（称为“状态”）和在不同状态之间的转换方式。状态转换图是行为建模的基础。

### 状态转换图、IPO图

* **状态转换图**

![image-20241225154033613](https://starofeden-blog.oss-cn-chengdu.aliyuncs.com/img/202412251540711.png)

状态名字必须有，其它两个可选

活动表3个事件：entry  do   exit

* **IPO图（输入、处理、输出图）**

（p69）

### 软件需求的正确性验证包含哪些内容

==一致性==	需求之间不能相互矛盾

==完整性==	包含每一个功能

==现实性==	现有技术能够实现

==有效性==	需求正确有效，能解决问题

## 第5章

### **总体设计过程包含的步骤**（简答）

1. 设计供选择的方案

2. 选取合理的方案                               系统设计阶段

3. 推荐最佳方案                                    

---

4. 功能分解

5. 设计软件结构                                   结构设计阶段

6. 设计数据库

7. 制定测试计划

8. 书写文档

9. 审查与复审

### 软件设计的基本原理

* **模块化**

  把程序划分成模块，每个模块完成一个子功能

  **模块化的根据**：把复杂的问题分解成许多容易解决的小问题

  ![image-20241225202835490](https://starofeden-blog.oss-cn-chengdu.aliyuncs.com/img/202412252028577.png)

  优点：

  ![image-20241225202954801](https://starofeden-blog.oss-cn-chengdu.aliyuncs.com/img/202412252029852.png)

![image-20241225203711978](https://starofeden-blog.oss-cn-chengdu.aliyuncs.com/img/202412252037036.png)

![image-20241225203748714](https://starofeden-blog.oss-cn-chengdu.aliyuncs.com/img/202412252037786.png)

这里的耦合与内聚是面向结构的

* **耦合**：不同模块之间的紧密程度 <span alt="solid">追求低耦合</span>（尽可能数据耦合）

  ==数据耦合==

  控制耦合

  特征耦合

  公共元素耦合

  内容耦合

  ![image-20241225204306692](https://starofeden-blog.oss-cn-chengdu.aliyuncs.com/img/202412252043779.png)

* **内聚**：一个模块内各个元素的紧密程度  <span alt="solid">追求高内聚（尽可能功能内聚）</span>

  ![image-20241225204725185](https://starofeden-blog.oss-cn-chengdu.aliyuncs.com/img/202412252047278.png)

==高内聚，低耦合==

### **软件设计启发式规则（简答题）**

1. 改进软件结构提高模块==独立性==
2. 模块==规模==应该适中
3. ==深度、宽度、扇出和扇入==都应适当
4. 模块的==作用域==应该在==控制域==之内
5. 力争降低模块==接口==的复杂程度
6. 设计==单入口单出口==的模块
7. 模块==功能==应该可以==预测==

### 深度、宽度、扇入、扇出

* 深度
  软件==控制==的==层数==
* 宽度
软件结构内==同一层次上==的模块总数的最大值
* 扇出
一个模块直接控制的==模块数目==
* 扇入
表明有多少个==上级模块==直接调用它

### 数据流分析：**变换型**与**事务型**

事务型数据流图：有很多岔路

### 软件结构图

==层次图==	 ==HIPO图==	 ==结构图==

HIPO图=层次图+IPO图

* 结构图

  （p103）

  空心圆：传递数据        实心圆：传递控制系



## 第6章

### 软件详细设计阶段遵循原则与结构化思想

* **结构化**

  如果一个程序的代码块仅仅通过==顺序==、==选择==和==循环==这3种基本控制结构进行连接，并且每个代码块只有==一个入口==和==一个出口==，则称这个程序是结构化的

* **原则**

  1. 模块的逻辑描述正确可靠、清晰易读。

  2. 选择适当的描述工具来对各模块的算法进行描述。

  3. 采用==结构化程序设计==方法，改善控制结构，降低程序复杂度，提高程序的可读性、可测试性和可维护性。

     

### 三种基本、两种扩展以及修正的结构

* **三种基本结构**

  顺序结构

  ==IF_THEN_ELSE==（选择结构）

  ==DO_WHILE==（循环结构）

* **两种扩展结构**

  ==DO_UNTIL==

  ==DO_CASE==（多分支结构）

* **修正的结构**

  LEAVE（或==BREAKE==）
  
  

### NS图的特点

1. 功能域（即一个特定控制结构的作用域）明确，可以从盒图上一眼就看出来
2. 不可能任意转移控制
3. 很容易确定局部和全程数据的作用域
4. 很容易表现嵌套关系，也可表示模块的层次结构

### **NS盒图、程序流程图,相互转换**（应用题）

* 程序流程图

![IMG_20241226_151235_edit_603136905051117](https://starofeden-blog.oss-cn-chengdu.aliyuncs.com/img/202412261513600.jpg)

菱形：选择

椭圆：开始、结束

矩形：处理

平行四边形：输入输出

* **NS盒图**（p127）

  ![image-20241226151750330](https://starofeden-blog.oss-cn-chengdu.aliyuncs.com/img/202412261517391.png)



### **环形复杂度的定义与三种计算方法**（应用题）

* **定义**

  McCabe方法根据程序控制流的复杂程度定量度量程序的复杂程度，这样度量出的结果称为程序的==环形复杂度==

* 三种计算方法

  1. 环形复杂度 V（G）等于流图中的**区域数**；

  2. 环形复杂度 V（G）＝E - N + 2，其中E是流图中**边的条数**，N是**结点数**；

  3. 环形复杂度 V（G）＝P + 1，其中P为流图中判定结点的数目。



## 第7章

### 软件测试的目的与流程

* 目的

  1. 测试是为了**发现错误**而执行程序的过程
  2. 好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案
  3. 成功的测试是发现了迄今为止尚未发现的错误的测试

  总结：**测试是为了发现程序中的错误，而不是为了表明程序是正确的**

* 流程

  模块测试、子系统测试、系统测试、验收测试、平行运行

### 白盒测试与黑盒测试的差别

| 白盒测试           | 黑盒测试       |
| ------------------ | -------------- |
| 结构测试           | 功能测试       |
| 知道程序内部的结构 | 不考虑程序内部 |
| 早期阶段           | 后期阶段       |





